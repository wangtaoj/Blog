### 表级锁

表级锁分为3类

#### 表锁

分为共享锁(S)、排它锁(X)

```mysql
# 给表t0加S锁, t1加X锁 
LOCK TABLES t0 READ, t1 WRITE;
# 释放锁
UNLOCK TABLES;
```

#### 意向锁

也分为共享锁(IS)、排它锁(IX)。意向锁由MySQL自己添加，设计的目的主要是为了快速判断表中是否有加行锁。

当MySQL添加**行锁中的排他锁**时，会先加意向排它锁(IX)，添加**行锁中的共享锁**时，会先添加意向共享锁(IS)。

典型的加锁语句

```mysql
# 会自动添加t表的排它意向锁(IX), 或者update、delete、insert等加行锁的语句
select * from t where id = 1 for update;

# 会自动添加t表的共享意向锁(IS)
select * from t where id = 1 lock in share mode;

# 普通查询语句，不会加表的意向锁，因为没有加行锁
select * from t where id = 1
```

**表级意向锁只会和表锁冲突，和其它类型的锁(包括自己)都不冲突。**

|      | S(表锁) | X(表锁) |
| ---- | ------- | ------- |
| IS   | 兼容    | 互斥    |
| IX   | 互斥    | 互斥    |

有了表级意向锁之后，加入t表目前有一条数据被加了行锁(X锁)，意味着表上肯定存在意向排它锁(IX)，此时另外一个线程想要对表加共享锁(S)或者排它锁(X)，便会被表上的意向排它锁(IX)阻塞。**如果没有设计意向锁，则加表锁时需要遍历表来判断有没有被加行锁，效率就低了。**

**反过来，如果一个线程先加了表的排它锁(X)，此时另外一个线程想要对表中的数据加行锁，因为要先加表的意向锁，于是便会被表上的排它锁阻塞住。**

#### 元数据锁

即metadata lock，简称mdl。设计的目的是为了解决DDL语句和DML语句冲突问题。

**元数据锁需要事务完成后才会被释放**

从MySQL5.6开始，MySQL已经支持Online DDL。Online的含义便是在执行DDL语句的时候，DML语句不会被阻塞，可以同时执行，**注意一定是DDL语句先执行。如果DML语句先执行，且没有提交或者回滚事务，也就是说元数据锁没有被释放，那么DDL语句会被阻塞**。

元数据锁加锁时机：

**当执行DML语句时，即增删改查会加mdl共享锁，查询加SHARED_READ，增删改加SHARED_WRITE，都是共享锁。**

**执行DDL语句时会先加mdl排它锁(EXCLUSIVE)**

**mdl锁只会和mdl锁冲突，共享锁之间是兼容的，排它锁与排它锁、共享锁互斥**

关于Online DDL

不是所有的DDL语句都是Online的，Online DDL语句基本流程如下。

* 加元数据排它锁，这一步是保护自己，防止其它DDL语句并发修改，只要能加上元数据排它锁，这一步耗时非常短。
* 降级成元数据共享锁，此时DML语句可以执行了，DDL语句仍然会被阻塞，因为DDL语句要先加排它锁，和当前持有的共享锁冲突。
* 真正做DDL语句，修改类的语句(alter table)都是要建一个新的临时表然后拷贝数据到这个新表，这一步耗时长。
* 再次升级成排它锁，阻止后续的DML语句，将期间并发执行的DML语句改动拷贝到新表，重命名新表为原来的表名。

### 行级锁

**注意: 行级锁都是在索引上加锁的**

#### 记录锁(Record Lock)

锁在确定的行上

#### 间隙锁(Gap Lock)

索引上不存这些记录，全部开区间，如(5, 10)

间隙锁是可重复读隔离级别下引入的，用于减少幻读，主要解决的是当前读的幻读，快照读的幻读用MVCC解决。

```mysql
/*
 * 前提，隔离级别为可重复读
 * t表只有主键id一个字段，存在5、10两条数据
 * 线程在事务中当前读，会阻塞别的线程对于id在(5, 10)之间的数据的插入
 * 该条语句会加(5, 10)的间隙锁
 * 因此在事务中再次执行该语句，不会出现幻读
 */
select * from t where id = 7 for update;
```

**注1：在可重复读隔离级别下，尽管引入了间隙锁，最大程度上可以避免幻读，但是不是百分百解决了幻读**。

```mysql
begin;
# 先快照读
select * from t where id = 7;
# 再当前读，如果另外一个线程在这两个语句中间插入了7这条记录(此时没有间隙锁，可以插入)，那么当前读会读到7这条记录
select * from t where id = 7 for update;
commit;
```

**注2：间隙锁是会变化的**

假如t表有1，5，10，15这4行数据

执行`select * from t where id = 7 for update;`

在`performance_schema.data_locks`表中查看加锁情况，是间隙锁(5, 10)，表里只会展示间隙锁右边的10，左边需要根据数据推导。

此时删掉10这行，因为只有(5, 10)的间隙锁，不会阻塞10的删除。

在查询加锁情况，会看到间隙锁是15(右边)，此时的间隙锁便是(5, 15)了，如果在删除5，就是(1, 15)了

**注3：间隙锁只和插入意向锁冲突**

#### 插入意向锁

插入意向锁是一种特殊的间隙锁，和前面的间隙锁互斥，只有insert语句才会加插入间隙锁。

还是用前面的表和数据

线程1执行

```mysql
# 加(5, 10)的间隙锁
select * from t where id = 7 for update;
```

线程2执行

```mysql
/*
 * 插入时会定位到7这行的下一行数据，也就是10，检查10上面有没有间隙锁
 * 发现存在(5, 10)的间隙锁，于是在10这个位置的加上插入意向锁(5, 10)
 * 间隙锁的左边是可变的，如果5被删除了，会继续往上一条存在的记录找，右边是固定的
 */
insert into t values(7);
```

#### 临建锁(Next-Key Lock)

等于间隙锁+记录锁，左开右闭，如(5, 10]，等于(5, 10)间隙锁 + 10的记录锁。

#### 隐式锁

隐式锁不是一个新的锁类型，转成显示锁后就是上面说的锁，转换成显示锁之前在`performance_schema.data_locks`表中查不到。

insert插入时，不是立即就会加锁的，而是会有一个隐式锁，如果存在冲突时才会转换成显示锁，并且是由冲突的线程帮忙转换。

其他事务如果想对新插入的记录加锁发现冲突时，需要帮助原来的插入线程将隐式锁转换成显示锁**(加记录锁排它锁)**，然后自己进行等待状态，等待自己获取相关锁(锁的类型具体情况具体分析)

### 如何查看加锁信息

* performance_schema.data_locks，表锁(包含意向锁)、行锁
* performance_schema.metadata_locks，表锁中的元数据锁

关于data_locks表中LOCK_MODE说明

当LOCK_TYPE=RECORD时，代表行锁，根据LOCK_MODE来区分是行锁中的哪种锁

使用排它锁举例

* X，X后面没有任何说明便是Next-Key锁，Lock_DATA字段表示的是锁的右区间索引值
* X,REC_NOT_GAP，记录锁
* X,GAP，间隙锁，Lock_DATA字段表示的是间隙锁的右区间索引值
* X,GAP,INSERT_INTENTION，插入意向锁

共享锁也一样